//
// Created by coolrp on 1/16/19.
//
//减少箱子的数量,先存大件,贪心
//如果有大于3的长宽,那肯定要单独占一个箱子,然后再插入1X1或者2X2的补充,以达到用最少的箱子,先将长宽大于3X3的产品放入
//6 * 6,新占用的箱子数1,空闲为0
//5 * 5,            1,空闲1*1,11个
//4 * 4,            1,空闲2*2,5个
//3 * 3的箱子,分为4种情况:
// 3 * 3的箱子数目 % 4 == 0, 新占用的箱子为0,空闲为0
//                      1,             1,空闲1*1, 7个, 空闲2*2, 5个
//                      2,             2,空闲1*1, 6个, 空闲2*2, 3个
//                      3,             3,空闲1*1, 5个, 空闲2*2, 1个
//因为8 % 4 == 0,之后3*3箱子数目的情况不考虑
//算法:1.先将长宽大于3*3的产品放入箱子中.
//    2.比较剩下的2*2的空位和长宽为2*2的产品的数量:
//      如果空位较多,就将产品全部放入空位中,然后多处的空位装长宽为1*1的产品
//      如果空位较少,就打开新的箱子放多出来的长宽为2*2的产品,然后再安排剩下的空位装长宽为1*1的产品
//    3.将剩余的长宽为1*1的产品装入新的箱子中

#include <cstdio>

using namespace std;

int main() {
    //x表示1X1的空位数目, y表示2X2的空位数目, n表示需要的箱子
    int a, b, c, d, e, f, x, y, n;
    //表示3X3的产品分别是4k, 4k + 1, 4k + 2, 4k + 3
    //为3X3产品打开的新箱子中剩余2X2的空位数
    int u[4] = {0, 5, 3, 1};

    while (scanf("%d%d%d%d%d%d", &a, &b, &c, &d, &e, &f) != EOF) {
        if (!a && !b && !c && !d && !e && !f)
            break;
        //表示6*6,5*5,4*4,3*3存在时,需要的箱子数目,即长宽大于或等于3X3的产品所占的新箱子数目
        n = f + e + d + (c + 3) / 4;
        //表示2*2的空位数目
        y = 5 * d + u[c % 4];
        //判断2*2的货物数目和空闲的2*2位置数目
        if (b > y)
            //多出来的2X2箱子应该占用的新箱子数
            n += (b - y + 8) / 9;
        //计算还有多少1*1的位置
        x = 36 * n - 36 * f - 25 * e - 16 * d - 9 * c - 4 * b;
        //所有箱子剩下的1X1空格,计算1*1的货物数目和空闲的1*1位置数目
        if (a > x)
            n += (a - x + 35) / 36;
        printf("%d\n", n);
    }
    return 0;
}